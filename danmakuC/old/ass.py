import json
import logging
import math
import re


# from danmakuC.__version__ import __version__


class AssText:
    def __init__(self, width: int, height: int, reserve_blank: int, font_face: str, font_size: float, alpha: float,
                 duration_marquee: float, duration_still: float):
        self.width = width
        self.height = height
        self.reserve_blank = reserve_blank
        self.font_face = font_face
        self.font_size = font_size
        self.alpha = alpha
        self.duration_marquee = duration_marquee
        self.duration_still = duration_still
        self.styleid = f"danmakuC"
        self._text = """[Script Info]
; Script generated by danmakuC (based on Danmaku2ASS)
; https://github.com/HFrost0/danmakuC
Script Updated By: danmakuC (https://github.com/HFrost0/danmakuC)
ScriptType: v4.00+
PlayResX: %(width)d
PlayResY: %(height)d
Aspect Ratio: %(width)d:%(height)d
Collisions: Normal
WrapStyle: 2
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: %(styleid)s, %(fontface)s, %(fontsize).0f, &H%(alpha)02XFFFFFF, &H%(alpha)02XFFFFFF, &H%(alpha)02X000000, &H%(alpha)02X000000, 0, 0, 0, 0, 100, 100, 0.00, 0.00, 1, %(outline).0f, 0, 7, 0, 0, 0, 0

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
""" % {
            "width": self.width,
            "height": self.height,
            "fontface": self.font_face,
            "fontsize": self.font_size,
            "alpha": 255 - round(self.alpha * 255),
            "outline": max(self.font_size / 25.0, 1),
            "styleid": self.styleid,
        }

    def WriteCommentBilibiliPositioned(self, c):
        # BiliPlayerSize = (512, 384)  # Bilibili player version 2010
        # BiliPlayerSize = (540, 384)  # Bilibili player version 2012
        # BiliPlayerSize = (672, 438)  # Bilibili player version 2014
        BiliPlayerSize = (891, 589)  # Bilibili player version 2021 (flex)
        ZoomFactor = GetZoomFactor(BiliPlayerSize, (self.width, self.height))

        def GetPosition(InputPos, isHeight):
            isHeight = int(isHeight)  # True -> 1
            if isinstance(InputPos, int):
                return ZoomFactor[0] * InputPos + ZoomFactor[isHeight + 1]
            elif isinstance(InputPos, float):
                if InputPos > 1:
                    return ZoomFactor[0] * InputPos + ZoomFactor[isHeight + 1]
                else:
                    return BiliPlayerSize[isHeight] * ZoomFactor[0] * InputPos + ZoomFactor[isHeight + 1]
            else:
                try:
                    InputPos = int(InputPos)
                except ValueError:
                    InputPos = float(InputPos)
                return GetPosition(InputPos, isHeight)

        try:
            comment_args = safe_list(json.loads(c[3]))
            text = ASSEscape(str(comment_args[4]).replace("/n", "\n"))
            from_x = comment_args.get(0, 0)
            from_y = comment_args.get(1, 0)
            to_x = comment_args.get(7, from_x)
            to_y = comment_args.get(8, from_y)
            from_x = GetPosition(from_x, False)
            from_y = GetPosition(from_y, True)
            to_x = GetPosition(to_x, False)
            to_y = GetPosition(to_y, True)
            alpha = safe_list(str(comment_args.get(2, "1")).split("-"))
            from_alpha = float(alpha.get(0, 1))
            to_alpha = float(alpha.get(1, from_alpha))
            from_alpha = 255 - round(from_alpha * 255)
            to_alpha = 255 - round(to_alpha * 255)
            rotate_z = int(comment_args.get(5, 0))
            rotate_y = int(comment_args.get(6, 0))
            lifetime = float(comment_args.get(3, 4500))
            duration = int(comment_args.get(9, lifetime * 1000))
            delay = int(comment_args.get(10, 0))
            fontface = comment_args.get(12)
            isborder = comment_args.get(11, "true")
            from_rotarg = ConvertFlashRotation(rotate_y, rotate_z, from_x, from_y, self.width, self.height)
            to_rotarg = ConvertFlashRotation(rotate_y, rotate_z, to_x, to_y, self.width, self.height)
            styles = ["\\org(%d, %d)" % (self.width / 2, self.height / 2)]
            if from_rotarg[0:2] == to_rotarg[0:2]:
                styles.append("\\pos(%.0f, %.0f)" % (from_rotarg[0:2]))
            else:
                styles.append(
                    "\\move(%.0f, %.0f, %.0f, %.0f, %.0f, %.0f)"
                    % (from_rotarg[0:2] + to_rotarg[0:2] + (delay, delay + duration))
                )
            styles.append("\\frx%.0f\\fry%.0f\\frz%.0f\\fscx%.0f\\fscy%.0f" % (from_rotarg[2:7]))
            if (from_x, from_y) != (to_x, to_y):
                styles.append("\\t(%d, %d, " % (delay, delay + duration))
                styles.append("\\frx%.0f\\fry%.0f\\frz%.0f\\fscx%.0f\\fscy%.0f" % (to_rotarg[2:7]))
                styles.append(")")
            if fontface:
                styles.append("\\fn%s" % ASSEscape(fontface))
            styles.append("\\fs%.0f" % (c[6] * ZoomFactor[0]))
            if c[5] != 0xFFFFFF:
                styles.append("\\c&H%s&" % ConvertColor(c[5]))
                if c[5] == 0x000000:
                    styles.append("\\3c&HFFFFFF&")
            if from_alpha == to_alpha:
                styles.append("\\alpha&H%02X" % from_alpha)
            elif (from_alpha, to_alpha) == (255, 0):
                styles.append("\\fad(%.0f,0)" % (lifetime * 1000))
            elif (from_alpha, to_alpha) == (0, 255):
                styles.append("\\fad(0, %.0f)" % (lifetime * 1000))
            else:
                styles.append(
                    "\\fade(%(from_alpha)d, %(to_alpha)d, %(to_alpha)d, 0, %(end_time).0f, %(end_time).0f, %(end_time).0f)"
                    % {"from_alpha": from_alpha, "to_alpha": to_alpha, "end_time": lifetime * 1000}
                )
            if isborder == "false":
                styles.append("\\bord0")
            self._text += "Dialogue: -1,%(start)s,%(end)s,%(styleid)s,,0,0,0,,{%(styles)s}%(text)s\n" % {
                "start": ConvertTimestamp(c[0]),
                "end": ConvertTimestamp(c[0] + lifetime),
                "styles": "".join(styles),
                "text": text,
                "styleid": self.styleid,
            }
        except (IndexError, ValueError) as e:
            try:
                logging.warning("Invalid comment: %r" % c[3])
            except IndexError:
                logging.warning("Invalid comment: %r" % c)

    def WriteComment(self, c, row):
        text = ASSEscape(c[3])
        styles = []
        if c[4] == 1:
            styles.append("\\an8\\pos(%(halfwidth)d, %(row)d)" % {"halfwidth": self.width / 2, "row": row})
            duration = self.duration_still
        elif c[4] == 2:
            styles.append(
                "\\an2\\pos(%(halfwidth)d, %(row)d)"
                % {"halfwidth": self.width / 2, "row": ConvertType2(row, self.height, self.reserve_blank)}
            )
            duration = self.duration_still
        elif c[4] == 3:
            styles.append(
                "\\move(%(neglen)d, %(row)d, %(width)d, %(row)d)"
                % {"width": self.width, "row": row, "neglen": -math.ceil(c[8])}
            )
            duration = self.duration_marquee
        else:
            styles.append(
                "\\move(%(width)d, %(row)d, %(neglen)d, %(row)d)"
                % {"width": self.width, "row": row, "neglen": -math.ceil(c[8])}
            )
            duration = self.duration_marquee
        if not (-1 < c[6] - self.font_size < 1):
            styles.append("\\fs%.0f" % c[6])
        if c[5] != 0xFFFFFF:
            styles.append("\\c&H%s&" % ConvertColor(c[5]))
            if c[5] == 0x000000:
                styles.append("\\3c&HFFFFFF&")
        self._text += "Dialogue: 2,%(start)s,%(end)s,%(styleid)s,,0000,0000,0000,,{%(styles)s}%(text)s\n" % {
            "start": ConvertTimestamp(c[0]),
            "end": ConvertTimestamp(c[0] + duration),
            "styles": "".join(styles),
            "text": text,
            "styleid": self.styleid,
        }

    def __str__(self):
        return self._text

    def to_string(self):
        return self._text


# Result: (f, dx, dy)
# To convert: NewX = f*x+dx, NewY = f*y+dy
def GetZoomFactor(SourceSize, TargetSize):
    try:
        if (SourceSize, TargetSize) == GetZoomFactor.Cached_Size:
            return GetZoomFactor.Cached_Result
    except AttributeError:
        pass
    GetZoomFactor.Cached_Size = (SourceSize, TargetSize)
    try:
        SourceAspect = SourceSize[0] / SourceSize[1]
        TargetAspect = TargetSize[0] / TargetSize[1]
        if TargetAspect < SourceAspect:  # narrower
            ScaleFactor = TargetSize[0] / SourceSize[0]
            GetZoomFactor.Cached_Result = (ScaleFactor, 0, (TargetSize[1] - TargetSize[0] / SourceAspect) / 2)
        elif TargetAspect > SourceAspect:  # wider
            ScaleFactor = TargetSize[1] / SourceSize[1]
            GetZoomFactor.Cached_Result = (ScaleFactor, (TargetSize[0] - TargetSize[1] * SourceAspect) / 2, 0)
        else:
            GetZoomFactor.Cached_Result = (TargetSize[0] / SourceSize[0], 0, 0)
        return GetZoomFactor.Cached_Result
    except ZeroDivisionError:
        GetZoomFactor.Cached_Result = (1, 0, 0)
        return GetZoomFactor.Cached_Result


# Calculation is based on https://github.com/jabbany/CommentCoreLibrary/issues/5#issuecomment-40087282
#                     and https://github.com/m13253/danmaku2ass/issues/7#issuecomment-41489422
# ASS FOV = width*4/3.0
# But Flash FOV = width/math.tan(100*math.pi/360.0)/2 will be used instead
# Result: (transX, transY, rotX, rotY, rotZ, scaleX, scaleY)
def ConvertFlashRotation(rotY, rotZ, X, Y, width, height):
    def WrapAngle(deg):
        return 180 - ((180 - deg) % 360)

    rotY = WrapAngle(rotY)
    rotZ = WrapAngle(rotZ)
    if rotY in (90, -90):
        rotY -= 1
    if rotY == 0 or rotZ == 0:
        outX = 0
        outY = -rotY  # Positive value means clockwise in Flash
        outZ = -rotZ
        rotY *= math.pi / 180.0
        rotZ *= math.pi / 180.0
    else:
        rotY *= math.pi / 180.0
        rotZ *= math.pi / 180.0
        outY = math.atan2(-math.sin(rotY) * math.cos(rotZ), math.cos(rotY)) * 180 / math.pi
        outZ = math.atan2(-math.cos(rotY) * math.sin(rotZ), math.cos(rotZ)) * 180 / math.pi
        outX = math.asin(math.sin(rotY) * math.sin(rotZ)) * 180 / math.pi
    trX = (
            (X * math.cos(rotZ) + Y * math.sin(rotZ)) / math.cos(rotY)
            + (1 - math.cos(rotZ) / math.cos(rotY)) * width / 2
            - math.sin(rotZ) / math.cos(rotY) * height / 2
    )
    trY = Y * math.cos(rotZ) - X * math.sin(rotZ) + math.sin(rotZ) * width / 2 + (1 - math.cos(rotZ)) * height / 2
    trZ = (trX - width / 2) * math.sin(rotY)
    FOV = width * math.tan(2 * math.pi / 9.0) / 2
    try:
        scaleXY = FOV / (FOV + trZ)
    except ZeroDivisionError:
        logging.error("Rotation makes object behind the camera: trZ == %.0f" % trZ)
        scaleXY = 1
    trX = (trX - width / 2) * scaleXY + width / 2
    trY = (trY - height / 2) * scaleXY + height / 2
    if scaleXY < 0:
        scaleXY = -scaleXY
        outX += 180
        outY += 180
        logging.error("Rotation makes object behind the camera: trZ == %.0f < %.0f" % (trZ, FOV))
    return (trX, trY, WrapAngle(outX), WrapAngle(outY), WrapAngle(outZ), scaleXY * 100, scaleXY * 100)


def ASSEscape(s):
    def ReplaceLeadingSpace(s):
        sstrip = s.strip(" ")
        slen = len(s)
        if slen == len(sstrip):
            return s
        else:
            llen = slen - len(s.lstrip(" "))
            rlen = slen - len(s.rstrip(" "))
            return "".join(("\u2007" * llen, sstrip, "\u2007" * rlen))

    return "\\N".join(
        (
            ReplaceLeadingSpace(i) or " "
            for i in str(s).replace("\\", "\\\\").replace("{", "\\{").replace("}", "\\}").split("\n")
        )
    )


def ConvertTimestamp(timestamp):
    timestamp = round(timestamp * 100.0)
    hour, minute = divmod(timestamp, 360000)
    minute, second = divmod(minute, 6000)
    second, centsecond = divmod(second, 100)
    return "%d:%02d:%02d.%02d" % (int(hour), int(minute), int(second), int(centsecond))


def ConvertColor(RGB, width=1280, height=576):
    if RGB == 0x000000:
        return "000000"
    elif RGB == 0xFFFFFF:
        return "FFFFFF"
    R = (RGB >> 16) & 0xFF
    G = (RGB >> 8) & 0xFF
    B = RGB & 0xFF
    if width < 1280 and height < 576:
        return "%02X%02X%02X" % (B, G, R)
    else:  # VobSub always uses BT.601 colorspace, convert to BT.709
        ClipByte = lambda x: 255 if x > 255 else 0 if x < 0 else round(x)
        return "%02X%02X%02X" % (
            ClipByte(R * 0.00956384088080656 + G * 0.03217254540203729 + B * 0.95826361371715607),
            ClipByte(R * -0.10493933142075390 + G * 1.17231478191855154 + B * -0.06737545049779757),
            ClipByte(R * 0.91348912373987645 + G * 0.07858536372532510 + B * 0.00792551253479842),
        )


def ConvertType2(row, height, bottomReserved):
    return height - bottomReserved - row


def FilterBadChars(string: str) -> str:
    return re.sub("[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f]", "\ufffd", string)


class safe_list(list):
    def get(self, index, default=None):
        try:
            return self[index]
        except IndexError:
            return default
